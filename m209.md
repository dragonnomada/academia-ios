# Módulo 9. Clases, estructuras y protocolos

Por [Alan Badillo Salas](https://www.nomadacode.com)

## Tema: Clases y Estructuras

    ¿Qué son las clases y las estructuras?
    Similitudes entre clases y estructuras
    Diferencias entre clases y estructuras

### Conceptos clave

Las *clases* y las *estructuras* son bloques de construcción que nos permiten determinar la funcionalidad de nuestros programas organizados como modelos basados en *propiedades* y *métodos*.

Podemos decir que las *clases* y las *estructuras* son los modelos bases que pueden ser replicados a través de *instancias* para consumir la funcionalidad determinada por sus *métodos* y retener valores mediante sus *propiedades*.

Una *propiedad* es la retención de un valor de algún tipo en la declaración de la *clase* o *estructura*.

Un *método* es una función contenedida en la declaración de la *clase* o *estructura* con acceso a la *instancia* para manipular las *propiedades* y sus valores asociados, devolviendo opcionalmente un cómputo resultante cómo cualquier función.

Las *clases* y *estructuras* son similares en: 

* **Propiedades** - Usadas para retener valores en la *instancia* 
* **Métodos** - Usados para realizar funcionalidad sobre las propiedades de la *instancia* 
* **Inicializadores** - Usados para construir la *instancia*, asignando los valores por iniciales de las propiedades
* **Subscrpts** - Usados para acceder a las propiedades en forma de arreglos y matrices
* **Extensiones** - Usados para extender propiedades y métodos a *clases* y *estructuras* ya definidos

Las *clases* y *estructuras* son diferentes en:

* **TIPO** - Los valores producidos por una *estructura* es un conjunto de valores (*value-type*) almacenado en la memoria de pila (*stack-memory*), mientras que los valores producidos por una *clase* es la referencia a una instacia (*reference-type*) almacenado en la memoria del montículo (*heap-memory*).
* **Herencia** - Las *estructuras* no son heredables, las *clases* si lo son.
* **Deinicializadores** - Las *estructuras* no tienen deinicializadores, las *clases* si tienen.

### Analogía

Podemos pensar a las *estructuras* y *clases* como *impresoras de objetos*.

La *instancia* sería equivalente a cada objeto impreso, el cuál es único aunque tengamos varios similares de ellos.

Las *propiedades* serían los valores del objeto impreso (la *instancia*), como su color, dimensiones, nombre, etc.

Los *métodos* serían las operaciones que se le pueden aplicar a un objeto, por ejemplo, cambiarle el color, obtener su nombre, determinar si sus dimensiones caben en una caja, etc.

### Ejemplo

> Definición de una estructura para retener los datos de un producto y determinar si tiene existencias

```swift
struct Producto {

    let nombre: String
    var precio: Double
    var existencias: Int

    init(nombreInicial: String, precioInicial: Double, existenciasIniciales: Int) {
        self.nombre = nombreInicial
        self.precio = precioInicial
        self.existencias = existenciasIniciales
    }

    func tieneExistencias() -> Bool {
        return self.existencias > 0
    }

}
```

> Definición de una clase para almacenar un arreglo de productos en un almacén

```swift
class Almacen {

    let productos: [Producto]
    var limite: Int

    init(limiteInicial: Int) {
        self.productos = []
        self.limite = limiteInicial
    }

    func agregarProducto(producto: Producto) -> Bool {
        if (self.productos.count < self.limite) {
            self.productos.append(producto)
            self.limite += 1
            return true
        } else {
            return false
        }
    }

}
```

### Ejercicios

> `[E20901]` - Agrega un método llamado `func sinExistencias() -> Bool` a `struct Producto` que devuelva si el producto tiene `0` existencias.

> `[E20902*]` - Agrega un método llamado `func capacidadDisponible() -> Int` a `class Almacen` que devuelva cuántos productos se pueden agregar antes de llegar al límite.

## Tema: Instancias, valores y referencias

    Valor versus tipos de referencia
    Creación de una clase o estructura

### Conceptos clave

### Analogía

### Ejemplo

### Ejercicios

## Tema: Propiedades

    Propiedades
    Propiedades almacenadas
    Propiedades calculadas
    Observadores de la propiedad

### Conceptos clave

### Analogía

### Ejemplo

> Ejemplo de una propiedad almacenada

```swift
struct Producto {
    let id: Int
    let nombre: String
    var precio: Double
    var existencias: Int
}
```

> Ejemplo de propiedades computadas

```swift
struct Producto {
    ...
    let hayExistencias: Bool {
        get { self.existencias > 0 }
    }
    var precioActual: Bool {
        get { self.precio }
        set { self.precio = newValue }
    }
    var existenciasActuales: Bool {
        get { self.existencias }
        set(nuevasExistencias) { self.existencias = nuevasExistencias }
    }
}
```

> Ejemplo de un observador de la propiedad

```swift
struct Producto {
    ...
    var existencias: Int = 0 {
        // newValue
        willSet(nuevasExistencias) {
            if nuevasExistencias < 0 {
                // Generar error: No pueden haber existencias negativas
            }
        }
        // oldValue
        didSet(existenciasAnteriores) {
            if existencias > existenciasAnteriores + 10 {
                // Generar error: Las existencias no pueden superar a las anteriores en más de 10
            }
        }
    }
}
```

### Ejercicios

## Tema: Métodos e inicializadores

    Métodos
    Inicializadores personalizados
    Nombres de parámetros internos y externos
    Inicializadores fallidos

### Conceptos clave

### Analogía

### Ejemplo

> Ejemplo de un inicializador fallido

```swift
struct Producto {
    ...
    init(id: Int, nombre: String, precio: Double, existencias: Int) {
        ...
        if (existencias < 0) {
            return nil
        }
    }
}
```

### Ejercicios

## Tema: Tópicos avanzados de propiedades y funciones

    Controles de acceso
    Expresiones de Key-path como funciones
    Llamar a un tipo como una función

### Conceptos clave

### Analogía

### Ejemplo

> Ejemplo del control de acceso privado en una propiedad

```swift
struct Producto {
    private let id: Int
}
```

> Ejemplo de una expresión `key-path` usando `.map`

```swift
let productos: [Producto] = [...]

let nombresProductos = productos.map(\.nombre)
```

> Ejemplo de la llamada de una función como tipo

```swift
struct Producto {
    func callAsFunction() -> Double {
        return self.precio * self.existencias
    }
}

let producto = Producto(...)

let valorProducto: Double = producto()
```

### Ejercicios

## Tema: Herencia y sobrecarga

    Herencia
    Sobreescribiendo de métodos y propiedades
    Sobreescribir métodos
    Sobreescribir propiedades
    Prevención de sobreescrituras

### Conceptos clave

### Analogía

### Ejemplo

> Sobreescritura de un método

```swift
class PagoConTarjeta: Pago {

    override func pagar() -> Bool {
        // ...
    }

}
```

> Sobreescritura de una propiedad

```swift
class ProductoConIva: Producto {

    override var precioActual: Double {
        get { self.precio * 1.16 }
        set { self.precio = newValue / 1.16 }
    }

}
```

> Prevenir la sobreescritura de un método

```swift
class Tienda {

    final func cerrar() -> Bool {
        // ...
    }

}
```

### Ejercicios

## Tema: ProtocolosExtensiones

    Protocolos
    Sintaxis del protocolo
    Requisitos de propiedad
    Requisitos del método

### Conceptos clave

### Analogía

### Ejemplo

### Ejercicios

## Tema: Extensiones

    Extensiones

### Conceptos clave

### Analogía

### Ejemplo

### Ejercicios

## Tema: Propiedades engrapadas y cadenas opcionales

    Property wrappers
    Optional chaining

### Conceptos clave

### Analogía

### Ejemplo

### Ejercicios

---

## Comentarios

En este módulo el alumno se sometió a los conceptos de *estructura*, *clase*, *instancia*, *propiedad*, *método*, *protocolo* y *extensión*.

El alumno deberá ser capaz de:

* Explicar las similitudes y diferencias entre estructuras y clases
* Declarar una estructura con propiedades, métodos e inicializadores
* Definir un protocolo e implementarlo en una estructura o clase
* Definir una extensión para una estructura o clase

## Referencias

Enlace | Descripción
--- | ---
[https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html](https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html) | Referencia a las estructuras y clases